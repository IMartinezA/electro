import numpy as np
import scipy.linalg as sl   # Library for more routines of linear algebra
import scipy.sparse as sp       # Library for sparse matrix formats.
import scipy.sparse.linalg as splg  # Library for routines of linear algebra for sparse matrix formats from the package scipy.sparse


def laplace_bios_pre_computations(L):
    eles = np.arange(0, L + 1)
    l2_1 = 2*eles+1
    eles_1 = eles + 1
    pre_V = 1./l2_1
    K_out_times_minus_1 = eles/l2_1 - 0.5
    K_ast_out = eles_1/l2_1 - 0.5
    pre_W = eles*K_ast_out
    return pre_V, K_out_times_minus_1, K_ast_out, pre_W


def coefficients_pre_computations_2_mediums(sigma_e, sigma_i):
    sigma_e_i = sigma_e/sigma_i
    sigma_i_e = sigma_i/sigma_e
    return sigma_e_i, sigma_i_e


def numpy_direct_solver(matrix, b):
    return np.linalg.solve(matrix, b)


def scipy_palu_decomposition(matrix):
    lu, piv = sl.lu_factor(matrix)
    return lu, piv


def scipy_solve_with_lu(lu, piv, b):
    x = sl.lu_solve((lu, piv), b)
    return x


def full_matrix_electro_l_only(c_m, tau, sigma_e, sigma_i, r, L):
    sigma_e_i, sigma_i_e = coefficients_pre_computations_2_mediums(sigma_e, sigma_i)
    pre_V, K_out_times_minus_1, K_ast_out, pre_W = laplace_bios_pre_computations(L)

    pre_V = pre_V * r
    pre_W = pre_W / r
    num = L + 1

    MTF_1_sphere_full_matrix = np.zeros((4 * num, 4 * num))
    MTF_1_sphere_full_matrix[0:num, 0:num] = sigma_e_i * K_out_times_minus_1
    MTF_1_sphere_full_matrix[0:num, num:2 * num] = sigma_e_i * pre_V
    MTF_1_sphere_full_matrix[0:num, 2 * num:3 * num] = - sigma_e_i * 0.5
    MTF_1_sphere_full_matrix[num:2 * num, 0:num] = sigma_e_i * pre_W
    MTF_1_sphere_full_matrix[num:2 * num, num:2 * num] = sigma_e_i * K_ast_out
    MTF_1_sphere_full_matrix[num:2 * num, num:2 * num] = 0.5
    MTF_1_sphere_full_matrix[2 * num:3 * num, 0:num] = -0.5
    MTF_1_sphere_full_matrix[2 * num:3 * num, 2 * num:3 * num] = K_ast_out
    MTF_1_sphere_full_matrix[2 * num:3 * num, 3 * num:4 * num] = pre_V
    MTF_1_sphere_full_matrix[3 * num:4 * num, num:2 * num] = 0.5 * sigma_e_i
    MTF_1_sphere_full_matrix[3 * num:4 * num, 2 * num:3 * num] = pre_W
    MTF_1_sphere_full_matrix[3 * num:4 * num, 3 * num:4 * num] = K_out_times_minus_1

    below_part = np.zeros((num, 4 * num))
    below_part[0:num, 3 * num: 4 * num] = sigma_i
    next_part = np.zeros((5 * num, num))
    next_part[0:num, 0:num] = 0.25 * sigma_e_i
    next_part[0:num, 2 * num: 3 * num] = - 0.25
    next_part[0:num, 4 * num: 5 * num] = c_m / tau

    MTF_1_sphere_full_matrix = np.concatenate((np.concatenate((MTF_1_sphere_full_matrix, below_part), axis=0), next_part), axis=1)
    return MTF_1_sphere_full_matrix